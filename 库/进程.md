# 进程使用总结

* 使用模块: `multiprocessing`

* 创建流程:

>1.将需要执行的事件封装成函数
>2.通过模块的`Process`类创建进程对象，关联函数
>3.可以通过进程对象设置进程信息及属性
>4.通过进程对象调用`start`启动进程
>5.通过进程对象调用`join`回收进程资源

## 主要类和函数：

`Process()`

> 功能：创建进程对象
>
> 参数：
> 【target】绑定目标函数
> 【args】用于给目标函数位置传参
> 【k'wargs】用于目标函数键值传参

`p.start()`

> 功能：启动进程
>
> 注意 : 启动进程此时target绑定函数开始执行，该函数作为新进程执行内容，此时进程真正被创建

`p.join([time])`

> 功能：阻塞、等待回收进程
> 参数：阻塞时间

* 进程执行现象理解

> 新的进程是原有进程的子进程，子进程复制父进程的**全部内存空间**代码段，一个进程可以创建多个子进程。
>
> 子进程只执行指定的函数，其余内容均是父进程执行内容，但是子进程也拥有其他父进程资源。
>
> 各个进程在执行上互不影响，也没有先后顺序关系。
>
> 进程创建后，各个进程空间独立，相互没有影响。
>
> multiprocessing 创建的子进程中**无法使用标准输入`input`**。

* 进程对象属性

	* `p.name` 进程名称
	* `p.pid` 对应子进程的PID号
	* `p.is_alive()` 查看子进程是否在生命周期
	* `p.daemon` 设置父子进程的退出关系
	* 如果设置为`True`则该子进程会随父进程的退出而结束
	* 要求必须在`start()`前设置
	* 如果daemon设置成`True` 通常就不会使用 `join()`

## 进程相关函数

`os.getpid()`

> 功能：获取一个进程的PID值
> 返回值：返回当前进程的PID 

`os.getppid()`

> 功能： 获取父进程的PID号
> 返回值： 返回父进程PID

`sys.exit(info)`

> 功能：退出进程
> 参数：info 表示退出时打印内容

## 创建进程类

 进程的基本创建方法将子进程执行的内容封装为函数。如果我们更热衷于面向对象的编程思想，也可以使用类来封装进程内容。

创建步骤：

> 1.继承Process类
> 2.重写__init__方法添加自己的属性，使用super()加载父类属性
> 3.重写run()方法

使用方法:

> 1.实例化对象
> 2.调用start自动执行run方法
> 3.调用join回收进程


## 进程池

* 必要性

> 1.进程的创建和销毁过程消耗的资源较多
> 2.当任务量众多，每个任务在很短时间内完成时，需要频繁的创建和销毁进程。此时对计算机压力较大
> 3.进程池技术很好的解决了以上问题。

**原理**

>创建一定数量的进程来处理事件，事件处理完进 程不退出而是继续处理其他事件，直到所有事件全都处理完毕统一销毁。增加进程的重复利用，降低资源消耗。

**进程池实现**

1. 创建进程池对象，放入适当的进程
	`from multiprocessing import Pool`

`Pool(processes)`

> 功能： 创建进程池对象
> 参数： 指定进程数量，默认根据系统自动判定

2. 将事件加入进程池队列执行
	`pool.apply_async(func,args,kwds)`

> 功能: 使用进程池执行 func事件
> 参数： func 事件函数
> args 元组  给func按位置传参
> kwds 字典  给func按照键值传参

3. 关闭进程池
	`pool.close()`
4. 回收进程池中进程
	`pool.join()`

## 进程通信

* 必要性： 进程间空间独立，资源不共享，此时在需要进程间数据传输时就需要特定的手段进行数据通信。
* 常用进程间通信方法：消息队列，套接字等。

**消息队列使用**

* 通信原理： 在内存中开辟空间，建立队列模型，进程通过队列将消息存入，或者从队列取出完成进程间通信。

* 实现方法:

```python
from multiprocessing import Queue
    q = Queue(maxsize=0)
    # 功能: 创建队列对象
    # 参数：最多存放消息个数
    # 返回值：队列对象

    q.put(data,[block,timeout])
    # 功能：向队列存入消息
    # 参数：data  要存入的内容
    # block  设置是否阻塞 False为非阻塞
    # timeout  超时检测

    q.get([block,timeout])
    # 功能：从队列取出消息
    # 参数：block  设置是否阻塞 False为非阻塞
    # timeout  超时检测
    # 返回值： 返回获取到的内容

    q.full()   # 判断队列是否为满
    q.empty()  # 判断队列是否为空
    q.qsize()  # 获取队列中消息个数
    q.close()  # 关闭队列
```



